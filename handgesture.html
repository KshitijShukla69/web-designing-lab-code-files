<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Gesture Particles</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        select {
            background: #222;
            color: white;
            border: 1px solid #444;
            padding: 5px;
            border-radius: 4px;
            margin-bottom: 10px;
            width: 100%;
            cursor: pointer;
        }
        .status {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }
        .instructions {
            font-size: 0.8rem;
            color: #aaa;
            line-height: 1.4;
        }
        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #333;
            border-radius: 8px;
            transform: scaleX(-1); /* Mirror preview */
            opacity: 0.8;
            z-index: 50;
            background: #111;
        }
        /* Error message style */
        #error-msg {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Gesture Engine</h1>
        <select id="camera-select">
            <option value="" disabled selected>Select Camera...</option>
        </select>
        
        <div class="status" id="status-text">Initializing system...</div>
        <div class="instructions">
            â€¢ <strong>Index Finger:</strong> Controls light<br>
            â€¢ <strong>Pinch (Thumb+Index):</strong> Explosion Force<br>
            â€¢ Auto-morphs every 6 seconds
        </div>
    </div>

    <div id="error-msg"></div>

    <video id="input_video" style="display:none" autoplay playsinline muted></video>
    <canvas id="video-preview"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 12000; 
        const PARTICLE_SIZE = 0.2;
        
        // --- GLOBALS ---
        let scene, camera, renderer, particles, geometry;
        let handPosition = new THREE.Vector2(0, 0);
        let isHandDetected = false;
        let isPinching = false;
        let time = 0;
        let cameraStream = null;
        let hands = null;

        // Shape management
        const shapes = { sphere: [], heart: [], saturn: [], flower: [] };
        const shapeKeys = Object.keys(shapes);
        let currentShapeIndex = 0;

        // UI Elements
        const videoElement = document.getElementById('input_video');
        const previewCanvas = document.getElementById('video-preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const cameraSelect = document.getElementById('camera-select');
        const errorMsg = document.getElementById('error-msg');

        // --- CHECK ENVIRONMENT ---
        if (window.location.protocol === 'file:') {
            errorMsg.style.display = 'block';
            errorMsg.innerHTML = "âš  <strong>CAMERA BLOCKED</strong><br>You are running this file directly.<br>Please open it using a Local Server (VS Code Live Server) or localhost.";
            throw new Error("File Protocol Detected");
        }

        // --- MAIN INITIALIZATION ---
        initThree();
        initMediaPipe();
        animate();
        populateCameraList();

        // Cycle shapes timer
        setInterval(() => {
            currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
            updateShapeTarget();
        }, 6000);

        // --- 1. THREE.JS SETUP ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Generate geometry data
            generateSphere(shapes.sphere);
            generateHeart(shapes.heart);
            generateSaturn(shapes.saturn);
            generateFlower(shapes.flower);

            // Setup Buffers
            geometry = new THREE.BufferGeometry();
            const pos = new Float32Array(PARTICLE_COUNT * 3);
            const target = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const randoms = new Float32Array(PARTICLE_COUNT * 3);

            const c1 = new THREE.Color(0x00ffff);
            const c2 = new THREE.Color(0xff0088);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                pos[i*3] = shapes.sphere[i*3];
                pos[i*3+1] = shapes.sphere[i*3+1];
                pos[i*3+2] = shapes.sphere[i*3+2];
                target[i*3] = pos[i*3];

                const mix = c1.clone().lerp(c2, Math.random());
                colors[i*3] = mix.r;
                colors[i*3+1] = mix.g;
                colors[i*3+2] = mix.b;
                randoms[i*3] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geometry.setAttribute('target', new THREE.BufferAttribute(target, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('random', new THREE.BufferAttribute(randoms, 1));

            const getTexture = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 32, 32);
                const tex = new THREE.Texture(canvas);
                tex.needsUpdate = true;
                return tex;
            };

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                map: getTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 2. MEDIAPIPE & CAMERA SETUP ---
        async function initMediaPipe() {
            hands = new Hands({locateFile: (file) => {
                return https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file};
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            startCamera();
        }

        function onHandsResults(results) {
            previewCanvas.width = videoElement.videoWidth || 640;
            previewCanvas.height = videoElement.videoHeight || 480;
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const lm = results.multiHandLandmarks[0];
                drawLandmarks(previewCtx, lm); 

                const indexTip = lm[8];
                const thumbTip = lm[4];

                handPosition.x = (1 - indexTip.x) * 2 - 1;
                handPosition.y = -indexTip.y * 2 + 1;

                const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                isPinching = dist < 0.05;
                
                statusText.innerText = isPinching ? "State: EXPLOSION ðŸ’¥" : "State: Tracking âœ‹";
                statusText.style.color = isPinching ? "#ff3366" : "#00ff00";
            } else {
                isHandDetected = false;
                statusText.innerText = "Looking for hands...";
                statusText.style.color = "#ffff00";
            }
        }

        function drawLandmarks(ctx, landmarks) {
            ctx.fillStyle = 'red';
            for(let p of landmarks) {
                ctx.beginPath();
                ctx.arc(p.x * ctx.canvas.width, p.y * ctx.canvas.height, 3, 0, 2*Math.PI);
                ctx.fill();
            }
        }

        // --- CAMERA HANDLING ---
        async function populateCameraList() {
            // Check if browser supports mediaDevices
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                console.log("enumerateDevices() not supported.");
                return;
            }

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                cameraSelect.innerHTML = '<option value="" disabled selected>Select Camera...</option>';
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || Camera ${index + 1};
                    cameraSelect.appendChild(option);
                });

                cameraSelect.onchange = () => {
                    startCamera(cameraSelect.value);
                };
            } catch (err) {
                console.error("Error listing cameras:", err);
            }
        }

        async function startCamera(deviceId = null) {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    deviceId: deviceId ? { exact: deviceId } : undefined,
                    width: { ideal: 640 }, 
                    height: { ideal: 480 }
                }
            };

            try {
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = cameraStream;
                // Note: videoElement.play() is handled by 'autoplay' in HTML, 
                // but we call it here to be safe after setting src.
                await videoElement.play();
                statusText.innerText = "Camera Active. Loading Model...";
                processVideo();
            } catch (err) {
                console.error("Camera Error:", err);
                statusText.innerText = "Camera Access Denied or Unavailable!";
                statusText.style.color = "red";
                alert("Camera failed to start. Ensure you are on HTTPS or Localhost.");
            }
        }

        async function processVideo() {
            // Ensure video is actually playing and has data
            if (videoElement.readyState >= 2 && !videoElement.paused && !videoElement.ended) {
                try {
                    await hands.send({image: videoElement});
                } catch(e) {
                    console.error("MediaPipe Error:", e);
                }
            }
            requestAnimationFrame(processVideo);
        }

        // --- 3. ANIMATION LOOP ---
        function updateShapeTarget() {
            const key = shapeKeys[currentShapeIndex];
            const data = shapes[key];
            const attr = geometry.attributes.target;
            for(let i=0; i<PARTICLE_COUNT*3; i++) {
                attr.array[i] = data[i];
            }
            attr.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const positions = geometry.attributes.position.array;
            const targets = geometry.attributes.target.array;
            
            const vector = new THREE.Vector3(handPosition.x, handPosition.y, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let x = positions[i3];
                let y = positions[i3+1];
                let z = positions[i3+2];
                
                x += (targets[i3] - x) * 0.04;
                y += (targets[i3+1] - y) * 0.04;
                z += (targets[i3+2] - z) * 0.04;

                if (isHandDetected) {
                    const dx = x - pos.x;
                    const dy = y - pos.y;
                    const dz = z - pos.z;
                    const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    const radius = isPinching ? 18 : 6;
                    const force = isPinching ? 2.0 : 0.5;

                    if (d < radius) {
                        const push = (1 - d/radius) * force;
                        x += dx * push;
                        y += dy * push;
                        z += dz * push;
                    }
                }

                x += Math.sin(time + y) * 0.02;

                positions[i3] = x;
                positions[i3+1] = y;
                positions[i3+2] = z;
            }

            geometry.attributes.position.needsUpdate = true;
            particles.rotation.y += 0.002;

            renderer.render(scene, camera);
        }

        // --- SHAPE GENERATORS ---
        function generateSphere(arr) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const r = 10 * Math.cbrt(Math.random()); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                arr.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
        }
        function generateHeart(arr) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                let t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let scale = 0.6;
                arr.push(x * scale, y * scale, (Math.random()-0.5) * 5);
            }
        }
        function generateSaturn(arr) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                if(Math.random() > 0.6) {
                    const r=4, t=Math.random()*6.28, p=Math.acos(Math.random()*2-1);
                    arr.push(r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p));
                } else {
                    const ang=Math.random()*6.28, d=6 + Math.random()*8;
                    let x=Math.cos(ang)*d, z=Math.sin(ang)*d, y=(Math.random()-0.5)*0.2;
                    let tilt=0.4;
                    arr.push(x, y*Math.cos(tilt)-z*Math.sin(tilt), y*Math.sin(tilt)+z*Math.cos(tilt));
                }
            }
        }
        function generateFlower(arr) {
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const u=Math.random()*6.28, v=Math.random()*3.14;
                const r = 8 * Math.cos(4 * u) + 2; 
                arr.push(r * Math.cos(u) * Math.sin(v), r * Math.sin(u) * Math.sin(v), (Math.random()-0.5)*3);
            }
        }
    </script>
</body>
</html>